
//*************************************************************************************************
//
// Сортировка данных в массиве
//
//*************************************************************************************************

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdbool.h>

#include "cmsis_os2.h"

#include "fram.h"
#include "sort.h"
#include "parse.h"
#include "uart.h"

//*************************************************************************************************
// Локальные переменные
//*************************************************************************************************
#pragma pack( push, 1 )

//структура для сортировки данных
typedef struct {
    uint16_t addr;
    uint64_t value;
 } DATA_SORT;

//структура для преобразования DD.MM.YYYY HH:MM:SS в YYYYMMDDHHMMSS
typedef struct {
    uint64_t value;
} DATA_DATE; 

#pragma pack( pop )

//*************************************************************************************************
// Локальные переменные
//*************************************************************************************************
static DATA_SORT data_sort[FRAM_BLOCKS-1];

//*************************************************************************************************
// Прототипы локальные функций
//*************************************************************************************************
static void Swap( uint8_t *el1, uint8_t *el2, uint8_t size );

//*************************************************************************************************
// Формирует массив данных в data_sort и выполняет сортировку по убыванию даты события в данных
//-------------------------------------------------------------------------------------------------
// return - кол-во элементов в массиме загруженных и отсортированных
//*************************************************************************************************
uint16_t MakeSort( void ) {

    uint16_t i, j, addr, cnt, min_index;
    DATA_DATE data_date;
    
    //обнуление массива перед загрузкой данных
    memset( (uint8_t *)&data_sort, 0x00, sizeof( data_sort ) );
    for ( cnt = 0, addr = FRAM_ADDR_LOG; addr < FRAM_SIZE && cnt < SIZE_ARRAY( data_sort ); addr += FRAM_BLOCK_SIZE ) {
        //чтение данных для сортировки
        if ( FramReadData( addr, (uint8_t *)&data_date, sizeof( data_date ) ) == FRAM_OK ) {
            //запись данных
            data_sort[cnt].addr = addr;
            memcpy( (uint8_t *)&data_sort[cnt].value, (uint8_t *)&data_date, sizeof( data_date ) );
            cnt++;
           }
       }
    //Cортировка выбором
    //1. находим номер минимального значения в текущем списке
    //2. обмен этого значения со значением первой неотсортированной позиции
    //3. продолжаем сортироку, исключив из рассмотрения уже отсортированные элементы
    for ( i = 0; i < cnt - 1; i++ ) {
        min_index = i;
        for ( j = i + 1; j < cnt; j++ ) {
            if ( data_sort[j].value > data_sort[min_index].value )
                min_index = j;
           }
        if ( min_index != i )
            Swap( (uint8_t *)&data_sort[i], (uint8_t *)&data_sort[min_index], sizeof( DATA_SORT ) );
       }
    return cnt;
 }

//*************************************************************************************************
// Функция возвращает адрес блока данных в FRAM памяти по указанному индексу.
//-------------------------------------------------------------------------------------------------
// Данные предварительно должны быть отсортированы с помощью MakeSort()
// uint16_t index - номер индекса, чем меньше индекс - тем новее данные
// return == 0    - индекс указан неправильно
//        != 0    - адрес блока данных в FRAM
//*************************************************************************************************
uint16_t GetAddrSort( uint16_t index ) {

    if ( index < SIZE_ARRAY( data_sort ) )
        return data_sort[index].addr;
    return 0;
 }

//*************************************************************************************************
// Перестановка данных местами между двумя массивами
//-------------------------------------------------------------------------------------------------
// uint8_t *el1 - указатель на первый массив
// uint8_t *el2 - указатель на второй массив
// uint8_t size - кол-во переставляемых байт
//*************************************************************************************************
static void Swap( uint8_t *el1, uint8_t *el2, uint8_t size ) {

    uint8_t swap[16];
    
    if ( size > sizeof( swap ) )
        return;
    memcpy( swap, el1,  size );
    memcpy( el1,  el2,  size );
    memcpy( el2,  swap, size );
 }
